<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Хеш-таблица</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>

<div class="description">
    <div class="description-section">
        <span class="description-section-title">Определение</span>
        <hr/>
        <div class="description-paragraph">
            <b>Хеш-таблица</b> – это структура данных, реализующая интерфейс ассоциативного массива, а именно,
            она позволяет хранить пары <i>ключ-значение</i> и выполнять три операции:
            <ul>
                <li>добавление новой пары;</li>
                <li>поиск по ключу;</li>
                <li>удаление пары по ключу.</li>
            </ul>
        </div>
        <div class="description-paragraph">
            В худшем случае поиск в хеш-таблице может занимать столько же времени, сколько поиск в списке — O(n), но на
            практике хеширование весьма эффективно.
            При выполнении некоторых условий время поиска элемента в хеш-таблице есть O(1).
        </div>
        <div class="description-paragraph">
            Хеш-таблицу можно рассматривать как обобщение обычного <i>массива</i>. Если достаточно памяти для массива,
            число элементов которого <i>равно</i>
            числу всех возможных ключей, то для каждого возможного ключа можно выделить ячейку в этом массиве ("<b>прямая
            адресация</b>").
            В этом случае время поиска всегда будет <i>const</i>. Но если реальное количество записей значительно <i>меньше</i>,
            чем количество возможных ключей, то эффективнее использовать <b>хеширование</b>: вычислять позицию записи в
            массиве, исходя из ключа.
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Основные понятия</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    При <i>хешировании</i> элемент с ключом <i>K</i> записывается в позицию номер <i>H(K)</i> в
                    хеш-таблице <i>T[0..m-1]</i>, где
                    <nobr><i>H: U → {0,1,…,m-1}</i></nobr>
                    —
                    некоторая функция, называемая <b>хеш-функцией</b>. Число <i>H(K)</i> называют <b>хеш-значением</b>
                    ключа <i>K</i>. Идея хеширования показана на рисунке справа:
                    пользуясь массивом длины <i>m</i>, а не <i>|U|</i>, мы экономим память.
                </div>
                <div class="description-paragraph">
                    Однако при <i>|U| > m</i> неизбежно существуют разные ключи, имеющие одно и то же хеш-значение. В
                    таких случаях говорят, что случилась <b>коллизия</b> или <b>столкновение</b>.
                    К счастью, эта проблема разрешима: хеш-функциями можно пользоваться и при наличии коллизий.
                </div>
                <div class="description-paragraph">
                    Для уменьшения количества коллизий разумно сделать хеш-функцию "<i>случайной</i>", хорошо
                    перемешивающей ключи по ячейкам. Разумеется, хеш-функция должна все же быть детерминированной:
                    при ее повторных вызовах с одним и тем же аргументом она должна возвращать одно и то же
                    хеш-значение.
                </div>
                <div class="description-paragraph">
                    Существуют <i>два</i> основных метода разрешения коллизий:
                    <ul>
                        <li>Разрешение коллизий методом цепочек.</li>
                        <li>Разрешение коллизий методом открытой адресации.</li>
                    </ul>
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtable.png" alt="hashtable"/>
                    <span class="description-image-title">Использование хеш-функции для отображения ключей в позиции хеш-таблицы. Хеш-значения ключей <i>K2</i> и <i>K3</i>
                совпадают — произошла коллизия</span>
                </div>
            </div>
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Разрешение коллизий методом цепочек</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    Технология <b>сцепления элементов</b> состоит в том, что элементы множества, которым соответствует
                    одно и то же хеш-значение, связываются в цепочку-список.
                    В позиции номер <i>j</i> хранится указатель на голову списка тех элементов, у которых хеш-значение
                    ключа равно <i>j</i>.
                </div>
                <div class="description-paragraph">
                    Операция добавления работает в худшем случае за время <i>O(1)</i>. Время работы поиска в наихудшем
                    случае пропорционально длине списка, а если все n ключей
                    захешировались в одну и ту же ячейку (создав список длиной n) время поиска будет равно <i>O(n)</i>.
                    Удаление элемента может быть выполнено за <i>O(1)</i> —
                    при условии, что списки двустронне связаны (если списки связаны односторонне, то для удаления
                    элемента надо предварительно найти его предшественника,
                    для чего необходим поиск по списку. В этом случае время удаления и поиска примерно одинаковы).
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtablewithchain.png" alt="hashtablewithchain"/>
                    <span class="description-image-title">Разрешение коллизий методом цепочек. В позиции <i>T[j]</i> хранится указатель на список элементов с хеш-значением <i>j</i>. Например, <i>H[K2] = H[K3]</i>.</span>
                </div>
            </div>
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Разрешение коллизий методом открытой адресации</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    В отличие от хеширования с цепочками, при <b>открытой адресации</b> списков нет, а все записи
                    хранятся в самой хеш-таблице: каждая ячейка содержит
                    либо элемент динамического множества, либо Null. Принцип поиска прост, необходимо просмотреть
                    элементы таблицы в определённых ячейках, пока не будет найден нужный,
                    или пока не будет доказано, что элемента с таким ключом нет в таблице. Таким образом, число хранимых
                    элементов всегда будет меньше размера самой таблицы.
                </div>
                <div class="description-paragraph">
                    При открытой адресации последовательность просматриваемых ячеек вычисляется. Чтобы добавить новый
                    элемент в таблицу, ячейки которой пронумерованы целыми числами
                    от <i>0</i> до <i>m - 1</i>, мы просматриваем её, пока не найдем свободное место. Но порядок
                    просмотра таблицы зависит от ключа. Здесь к <i>хеш-функции</i> добавляется
                    второй аргумент — номер попытки. Хеш-функция принимает вид:
                    <nobr><i>h: U × {0,1,…,m-1} → {0,1,…,m-1}</i></nobr>
                    , где <i>U</i> — множество ключей. <b>Последовательность
                    испробованных мест</b>, или <b>последовательность проб</b> для данного ключа <i>k</i> имеет вид
                    <nobr>〈<i>h(k,0), h(k,1), … , h(k,m-1)</i>〉</nobr>
                    функция <i>h</i>
                    должна быть такой, чтобы каждое из чисел от <i>0</i> до <i>m - 1</i> встречалось в этой
                    последовательности ровно один раз.
                </div>
                <div class="description-paragraph">
                    При поиске элемента с ключом <i>k</i> ячейки таблицы просматриваются в том же порядке, что и при
                    добавлении. Если при этом нам попалась ячейка, в которой записан Null,
                    то можно быть уверенным, что искомого элемента в таблице нет. Но удаление из таблицы с открытой
                    адресацией не так просто: необходимо записывать на место удаляемого элемента
                    не Null, а специальное значение DELETED, и при добавлении рассматривать данную ячейку как свободную,
                    а при поиске, как занятую.
                </div>
                <div class="description-paragraph">
                    Обычно применяют три способа вычисления последовательности испробованных мест: <b>линейный</b>, <b>квадратичный</b>
                    и <b>двойное хеширование</b>.
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtablewithopenaddress.png"
                         alt="hashtablewithopenaddress"/>
                    <span class="description-image-title">Разрешение коллизий методом открытой адресации</span>
                </div>
            </div>
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Линейная последовательность проб</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    Задана хеш-функция
                    <nobr><i>h: U → {0,1,…,m-1}</i></nobr>
                    , тогда функция, определяющая <b>линейную последовательность проб</b>, задается формулой
                    <nobr><i>H(k, i) = (h(k) + i) (mod m)</i></nobr>
                    . Таким образом, при возникновении очередной коллизии с ключом k поиск свободной ячейки начинают с
                    <i>T[h(k)]</i>, а затем перебирают ячейки таблицы подряд: <i>T[h(k) + 1]</i>, <i>T[h(k) + 2]</i>, и
                    т.д. (после <i>T[m - 1]</i> переходят
                    к <i>T[0]</i>).
                </div>
                <div class="description-paragraph">
                    Открытую адресацию с линейной последовательностью проб легко реализовать, но у этого метода есть
                    недостаток: он может привести к образованию
                    <b>кластеров</b>, то есть длинных последовательностей занятых ячеек, идущих подряд, что удлиняет
                    поиск. Из-за этого линейная последовательность
                    проб довольно далека от равномерного хеширования.
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtablewithlineartest.png"
                         alt="hashtablewithlineartest"/>
                    <span class="description-image-title">Разрешение коллизий методом открытой адресации с линейной последовательностью проб</span>
                </div>
            </div>
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Квадратичная последовательность проб</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    Функция, определяющая <b>квадратичную последовательность проб</b>, задаётся формулой
                    <nobr><i>H(k, i) = (h(k) + c<sub>1</sub>i + c<sub>2</sub>i
                        <sup>2</sup>) (mod m)</i></nobr>
                    , где <i>h</i> — хеш-функция, а <i>c<sub>1</sub></i> и <i>c<sub>2</sub></i> — некоторые константы.
                    Пробы начинаются
                    с ячейки номер <i>T[h(k)]</i>, как и при линейном методе, но дальше ячейки просматриваются не
                    подряд: номер пробуемой ячейки квадратично зависит
                    от номера попытки.
                </div>
                <div class="description-paragraph">
                    Этот метод работает значительно лучше, чем линейный, но, если мы хотим, чтобы при просмотре
                    хеш-таблицы использовались все ячейки,
                    значения <i>m</i>, <i>c<sub>1</sub></i> и <i>c<sub>2</sub></i> нельзя выбирать произвольно
                    (например, за <i>c<sub>1</sub></i> можно взять <i>1</i>,
                    а за <i>c<sub>2</sub></i> — <i>3</i>). Однако, тут проявляется эффект аналогичный кластерам, но в
                    более мягкой форме <b>образования вторичных кластеров</b>.
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtablewithquadtest.png"
                         alt="hashtablewithquadtest"/>
                    <span class="description-image-title">Разрешение коллизий методом открытой адресации с квадратичной последовательностью проб</span>
                </div>
            </div>
        </div>
    </div>
    <div class="description-section">
        <span class="description-section-title">Двойное хеширование</span>
        <hr/>
        <div class="description-paragraph-row">
            <div class="w-75">
                <div class="description-paragraph">
                    <b>Двойное хеширование</b> — один из лучших методов открытой адресации. Перестановки индексов,
                    возникающие при двойном хешировании, обладают многими свойствами,
                    присущими равномерному хешированию. Здесь функция <i>H</i> имеет вид
                    <nobr><i>H(k, i) = (h<sub>1</sub>(k) + ih<sub>2</sub>(k)) (mod m)</i></nobr>
                    , где
                    <i>h<sub>1</sub></i> и <i>h<sub>2</sub></i> — разные хеш-функции. Иными словами, последовательность
                    проб при работе с ключом <i>k</i> представляет собой
                    арифметическую прогрессию (по модулю <i>m</i>) с первым членом <i>h<sub>1</sub></i> и шагом
                    <i>h<sub>2</sub></i>.
                </div>
                <div class="description-paragraph">
                    Чтобы последовательность испробованных мест покрыла всю таблицу, значение <i>h<sub>2</sub>(k)</i>
                    должно быть взаимно простым с <i>m</i>.
                    Этого можно добиться, если выбрать в качестве <i>m</i> степень двойки, а функцию
                    <i>h<sub>2</sub></i> взять такую, чтобы она принимала только нечётные
                    значения. Другой вариант: <i>m</i> — простое число, значения <i>h<sub>2</sub></i> — целые
                    положительные числа, меньше <i>m</i>. Например, для простого <i>m</i>
                    можно положить
                    <nobr><i>h<sub>1</sub>(k) = k (mod m)</i></nobr>
                    ,
                    <nobr><i>h<sub>2</sub>(k) = 1 + (k (mod m'))</i></nobr>
                    , где <i>m'</i> чуть меньше, чем <i>m</i>
                    (например, <i>m' = m - 1</i> или <i>m' = m - 2</i>).
                </div>
                <div class="description-paragraph">
                    Производительность двойного хеширования близка к той, что получалась бы при настоящем равномерном
                    хешировании.
                </div>
            </div>
            <div class="w-25">
                <div class="description-image-container">
                    <img class="description-image" src="images/hashtablewithdoublehash.png"
                         alt="hashtablewithdoublehash"/>
                    <span class="description-image-title">Разрешение коллизий методом открытой адресации с двойным хешированием</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="js/get-document-height.js"></script>
</body>
</html>



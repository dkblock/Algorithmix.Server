<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Куча и её разновидности. Пирамидальная сортировка</title>
  <link rel="stylesheet" href="css/styles.css">
</head>

<body>
  <div class="description-section">
    <h class="description-section-title">Определение кучи</h>
    <hr />
    <div class="description-paragraph-row">
      <div>
        <div class="description-paragraph mb 8">
          <p><b>Куча</b> (<i>heap</i>) ― структура данных, представляющая собой объект-массив, который можно
            рассматривать как
            почти полное бинарное дерево. Различают два вида куч: невозрастающие (max-heap) и неубывающие ( min-heap ),
            для каждого из которых можно сформулировать основное свойство кучи.</p>
        </div>
        <div class="description-paragraph mb 8">
          <p> Куча полностью заполнена на всех уровнях, за исключением, возможно, самого нижнего, который заполняется
            слева направо элементами массива.
            Элементы, у которых нет потомков, называются <b>листьями</b>. Листья в куче начинаются с индекса <i>n/2</i>,
            где
            <i>n</i> &mdash; количество элементов в куче.<br><b>Глубина</b> всех листьев, расстояние до корня,
            отличается не больше
            чем на 1.<br> <b>Высота</b> кучи определяется как и у двоичного дерева: это количество ребер в простом пути,
            который
            необходимо пройти от корня до любого листа, вычисляется как log<sub>2</sub> <i>n</i>.<br>
            Максимальное количество элементов в куче, в которой k уровней: 2<sup>k</sup>-1, минимальное:
            2<sup>k-1</sup>.
          </p>
        </div>
        <h class="description-paragraph-title">Основное свойство кучи</h>
        <div class="description-paragraph mb 8">
          <p>Для невозрастающей кучи: значение узла не превышает значение родительского по
            отношению к нему узла. Для данного типа кучи характерно то, что в корне будет находиться элемент с самым
            большим приоритетом. </p>
          <p>В неубывающей куче приоритет родительского узла не больше приоритета дочернего.
            Таким образом в корне будет находится элемент с минимальным значением, поскольку все его потомки не меньше
            его.</p>
          <p>Благодаря основному свойству кучи, эта структура данных отлично подходит для поиска максимального или
            минимального
            элемента, следовательно и для сортировки.</p>
        </div>
      </div>
      <div class="w-50">
        <div>
          <div class="description-image-container">
            <img class="description-image" src="images\max-heap.png" alt="max-heap">
            <span class="description-image-title">Невозрастающая куча</span>
          </div>
        </div>
        <div>
          <div class="description-image-container">
            <img class="description-image" src="images\min-heap.png" alt="min-heap">
            <span class="description-image-title">Неубывающая куча</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="description-section">
    <h class="description-section-title">Хранение</h>
    <hr />
    <div class="description-paragraph-row">
      <div>

        <div class="description-paragraph mb 8">
          <p>Кучу удобно хранить в виде массива, это одно из главных преимуществ кучи, поскольку эта особенность
            позволяет
            наискорейшим образом обратиться к нужному элементу. Никаких ограничений на количество
            потомков узла не накладывается. В зависимости от их количества кучи называют бинарными, тернарными, <i>n</i>-арными. Для
            большей конкретики в дальнейшем мы будем рассматривать двоичную кучу, в которой у каждого узла не больше
            двух
            потомков (пирамида). <br> Каждый
            узел соответствует определенному элементу массива.
            Корню соответствует элемент <i>array[0]</i>.<br>
            Для узла с индексом <i>i</i>:
          <ul>
            <li>индекс родителя &mdash; <i>(i-1)/2</i></li>
            <li>индекс левого потомка &mdash; <i>2*i+1</i></li>
            <li>индекс правого потомка &mdash; <i>2*i+2</i></li>
          </ul>
          </p>
        </div>
      </div>
      <div class="w-75">
        <div class="description-image-container">
          <img class="description-image" src="images\heap-storage.png" alt="Хранение кучи с помощью массива">
          <span class="description-image-title">Индексация узлов кучи в массиве</span>
        </div>
      </div>
    </div>
  </div>
  <div class="description-section">
    <h class="description-section-title">Пирамидальная сортировка</h>
    <hr />
    <h class="description-paragraph-title">Просеивание</h>
    <div class="description-paragraph-row">
      <div class="description-paragraph mb 8">
        <p>
          Основная операция с бинарной кучей &mdash; просеивание (heapify), процедура восстановления свойств кучи.
        </br>
          Стандартная процедура просеивания заключается в следующем: берётся узел и сравнивается с его потомками. Если
          наибольший из
          потомков больше текущего узла, то меняем их местами. Повторяем данную манипуляцию для исходного элемента, пока
          не дойдем до нижнего уровня или пока значения дочерних узлов будут больше текущего. Приведенный алгоритм
          корректен для невозрастающей кучи, когда в корне находится максимальный элемент, для неубывающей же кучи вверх
          будет "всплывать" минимальный из потомков или оставаться текущий.
        </p>
        <p>
          Просеивание &mdash; основная процедура при сортировке с помощью кучи.
        </p>
      </div>
      <div class="w-75">
        <div class="description-image-container">
          <img class="description-image" src="images\heapify.gif" alt="Просеивание узла 1">
          <span class="description-image-title">Просеивание корневого узла</span>
        </div>
      </div>
    </div>

    <h class="description-paragraph-title">Алгоритм</h>
    <div class="description-paragraph-row">
      <div class="description-paragraph mb 8">
        <ol type="I">
          <li>
            <p>На вход поступил массив, не являющийся сортирующим деревом, требуется построить первичную кучу. Для этого
              нужно обойти все узлы с конца и выполнить просеивание каждого. Поскольку у листьев нет
              потомков, то основное свойство кучи для них выполняется автоматически, поэтому их можно пропустить.</p>
          </li>
          <li>
            <p>
              Первичная куча построена, в корне находится максимальный (минимальный) элемент.
              <br/> Пока в куче есть элементы:
            <ol type="i">
              <li>Меняем корень и последний элемент кучи местами, уменьшаем размер кучи на один. Таким образом,
                последний элемент массива уже не принадлежит куче;</li>
              <li>Просеиваем корень.</li>
            </ol>
            </p>
          </li>
          <li>Получившийся массив отсортирован.</li>
        </ol>
      </div>
      <div class="w-75">
        <div class="description-image-container">
          <img class="description-image" src="images\heapSort.gif" alt="Heap Sort">
          <span class="description-image-title">Пирамидальная сортировка</span>
        </div>
      </div>
    </div>

  </div>
  <div class="description-section mb-16">
    <h class="description-section-title">Структуры данных, основанные на куче</h>
    <hr />
    <ol type="I">
      <li><a href="#weakHeap">Слабая куча</a></li>
      <li><a href="#tree">Декартово дерево</a></li>
    </ol>
  </div>
  <div class="description-section">
    <h class="description-paragraph-title">Слабая куча</h>
    <div class="description-paragraph-row">
      <div>
        <div id="weakHeap" class="description-paragraph mb 8">
          <p><b>Слабая куча</b> (weak heap) - модифицированная модель привычной кучи, для которой выполняются следующие
            условия:</p>
          <ol>
            <li>У корневого узла нет левого поддерева, он обладает только правым потомком;</li>
            <li>Каждый правый потомок не меньше/не больше родителя в неубывающей куче и
              невозрастающей куче соответственно. На левых потоков никаких ограничений не накладывается.</li>
          </ol>
        </div>
        <div class="description-paragraph mb 8">
          <p>
            Поскольку корень обладает только правым дочерним элементом, то индексы потомков считаются иначе, нежели для
            обычной кучи. Пусть индекс элемента в массиве <i>i</i>, тогда индекс его правого потомка &mdash; <i>2*i</i>,
            левого &mdash; <i>2*i+1</i>.
          </p>
        </div>
        <div class="description-paragraph mb 8">
          <p>Благодаря второму свойству сокращаются издержки для поддержания свойств обычной кучи, ведь контролировать
            нужно не всех потомков, а только правых.<br/>Со слабой кучей можно выполнять те же операции, что и с обычной,
            она лишь является ее более изощренной версией, которая сложнее к пониманию, поэтому данная структура не
            получила особого распространения.</p>
        </div>
      </div>
      <div class="w-75">
        <div class="description-image-container">
          <img class="description-image" src="images\weak-heap.png" alt="Пример построения слабой кучи">
          <span class="description-image-title">Слабая куча</span>
        </div>
      </div>
    </div>
  </div>

  <div class="description-section mb-16">
    <h class="description-paragraph-title">Декартово дерево</h>
    <div class="description-paragraph-row">
      <div>
        <div  id="tree" class="description-paragraph mb 8">
          <p>
            <b>Декартово дерево</b>- структура данных, совмещающая в себе свойства бинарного дерева и кучи,
            отсюда и возможные варианты названия: дуча (дерево+куча), курево (куча+дерево), дерамида (дерево+пирамида).
          </p>
          <p>Каждая вершина в декартовом дереве характеризуется парой величин (<i>x</i>,<i>y</i>), где <i>x</i> - индекс
            текущего элемента в
            массиве, а <i>y</i> - его значение. Дерамида является бинарным деревом
            поиска, если смотреть на индексы элементов, и кучей, если смотреть на значения. То есть, если мы
            берем узел (<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>), то у элементов в правом поддереве
            <i>x</i>><i>x</i><sub>0</sub>, а в левом x<sub>0</sub>><i>x</i>, и у всех элементов
            <i>y</i>≤<i>y</i><sub>0</sub>для max-heap или <i>y</i>≥<i>y</i><sub>0</sub> для min-heap.<br/> Данную
            структуру хранить с помощью массива уже не получится, поэтому помимо полей <i>x</i>  и <i>y</i> каждый элемент должен
            хранить ссылку на правого и левого потомка, а по необходимости также на родительский узел.
          </p>
        </div>
      </div>
      <div class="w-75">
        <div class="mb-16">
          <div class="description-image-container">
            <img class="description-image" src="images\treap.png" alt="Пример построения дерамиды">
            <span class="description-image-title">Декартово дерево</span>
          </div>
        </div>
      </div>
    </div>
    <div class="description-paragraph-row">
      <div class="description-paragraph mb 8">
        <p>Если изобразить все узлы на декартовой плоскости, то получится рисунок, который очень похож на изображение
          дерева с корнем вверху. Таким образом, дерамида это одновременно бинарное дерево по <i>x</i> и куча по
          <i>y</i>, значит в корне будет находится максимальный или минимальный элемент в зависимости от типа кучи. Совсем не
          обязательно, что декартово дерево будет сбалансированным.</p>
      </div>
      <div>
        <div class="description-image-container">
          <img class="description-image" src="images\treap-2.png" alt="Дерамида на декартовой плоскости">
          <span class="description-image-title">Изображение узлов дерамиды на декартовой плоскости</span>
        </div>
      </div>
    </div>

  </div>
 <script src="js/get-document-height.js"></script>
</body>

</html>
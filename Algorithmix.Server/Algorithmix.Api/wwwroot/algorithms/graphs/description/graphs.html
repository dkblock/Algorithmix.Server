<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Алгоритмы на графах</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

<div class="description">
    <!-- Поиск в ширину   -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Поиск в ширину</span>
            <hr/>
            <div class="description-paragraph">
                <b>Поиск в ширину</b> — один из основных алгоритмов на графах, который позволяет найти кратчайшие пути
                от заданной вершины. Данный алгоритм используется, например, при индексации веб-страниц поисковыми
                ботами или при поиске в социальных сетях.
                <br>
                <b>Временная сложность алгоритма:</b> O(n + m), где n – число вершин, m – число рёбер
            </div>
        </div>
        <div class="description-section">
            <div class="description-paragraph-row">
                <div>
                    <div class="description-section">
                        <span class="description-section-title">Основная идея</span>
                        <hr/>
                        <div class="description-paragraph">
                            Идею алгоритма можно понимать, как процесс «поджигания» графа. На нулевом шаге мы
                            «поджигаем» стартовую вершину, а на каждом последующем огонь с уже горящей вершины переходит
                            на смежные с ней, т.е. на каждый шаг алгоритма происходит расширение огня. Номер вершины, на
                            которой она начинает гореть, равен длине её минимального пути от стартовой вершины
                        </div>
                    </div>
                    <div class="description-section">
                        <span class="description-section-title">Реализация алгоритма </span>
                        <hr/>
                        <ol>
                            <li>На вход подаётся граф и стартовая вершина</li>
                            <li>Создаётся очередь, в которую будут помещаться пройденные вершины, а также массив
                                visited, в котором будут храниться пройденные вершины
                            </li>
                            <li>В очередь помещается стартовая вершина и помечается в массиве visited как пройденная
                            </li>
                            <li>Пока очередь не пуста, достаём из её головы одну вершину, просматриваем все смежные с
                                ней, и добавляем в конец очереди те, которые ещё не пройдены
                            </li>
                        </ol>
                        <div class="description-paragraph">Когда очередь будет пуста, все достижимые вершины из
                            стартовой будут пройдены. Чтобы посчитать длины кратчайших путей,
                            нужно завести массив длины путей и при добавлении в очередь вершины рассчитывать её длину
                            как d<sub>u</sub> = d<sub>v</sub> + 1, где u – это вершина, на которой мы находимся,
                            а v её родитель. Также можно хранить массив предков, в которой для каждой вершины хранится
                            номер вершины, из которой мы в неё попали.
                        </div>
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image small-image" src="images/bfsGif.gif"/>
                </div>
            </div>
        </div>
    </section>

    <!-- Поиск в глубину   -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Поиск в глубину</span>
            <hr/>
            <div class="description-paragraph">
                <b>Поиск в глубину</b> — это рекурсивный алгоритм обхода графа. Он применяется, например, для нахождения
                пути между двумя вершинами, для обнаружения циклов на графе, в топологической сортировке.
                <br>
                <b>Временная сложность алгоритма:</b> O(n + m), где n – число вершин, m – число рёбер
            </div>
        </div>
        <div class="description-section">
            <div class="description-paragraph-row">
                <div>
                    <div class="description-section">
                        <span class="description-section-title">Основная идея</span>
                        <hr/>
                        <div class="description-paragraph-row">
                            <div class="description-paragraph">Основная идея поиска следует из названия, она состоит в
                                том, чтобы идти максимально «вглубь» графа, пока это возможно. Можно провести параллель с лабиринтом,
                                если мы хотим исследовать весь лабиринт, то нам нужно выбрать смежную вершину, обойти весь путь,
                                вернуться в исходную точку и повторять, пока не пройдём оставшиеся вершины
                            </div>
                        </div>
                    </div>
                    <div class="description-section">
                        <span class="description-section-title">Реализация алгоритма</span>
                        <hr/>
                        <ol>
                            <li>На вход подаётся граф и стартовая вершина</li>
                            <li>Создаётся массив visited, в котором будут храниться пройденные вершины, и массив предков.
                            </li>
                            <li>Помечаем стартовую вершину как просмотренную и начинаем обход смежных с ней вершин, при
                                этом, если вершина ещё не помечена как пройденная, то вызываем поиск в глубину для этой вершины.
                            </li>
                        </ol>
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image small-image" src="images/dfsGif.gif"/>
                </div>
            </div>
        </div>
    </section>

    <!-- Алгоритм Дейкстры   -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Алгоритм Дейкстры</span>
            <hr/>
            <div class="description-paragraph">
                <b>Алгоритм Дейкстры</b> – это алгоритм, который позволяет находить кратчайший путь от
                заданной вершины до всех остальных в графе без ребер отрицательного веса. Кратчайший путь – это путь,
                при котором сумма весов рёбер должны быть минимальна. Алгоритмы нахождения кратчайшего пути применяются,
                например, в сервисах для прокладки маршрута, в сетях для решения проблемы минимальной задержки пути.
                <br>
                Временная сложность алгоритма зависит от реализации, при простой реализации алгоритм работает за
                O(n<sup>2</sup> + m). Используя двоичную кучу можно ускорить время работы алгоритма до O(m logn).Самая
                быстрая реализация работает с использованием фибоначчиевой кучи, время работы выполнение алгоритма
                займёт O(n logn + m).
            </div>
        </div>
        <div class="description-section">
            <div class="description-paragraph-row">
                <div>
                    <div class="description-section">
                        <span class="description-section-title">Основная идея</span>
                        <hr/>
                        <div class="description-paragraph-row">
                            <div class="description-paragraph">Основная идея заключается в том, что на каждом шаге мы
                                пытаемся уменьшить кратчайшее
                                расстояние до нерассмотренных вершин, т.е. производим релаксацию – просматриваем все
                                рёбра, исходящие из вершины, и для каждой такой смежной вершины алгоритм пытается улучшить расстояние
                                таким образом: distance[u] = min(distance[u], distance[v] + length), где v – вершина, из которой
                                производим релаксацию, u – смежная вершина, а length – длина ребра {u, v}.
                            </div>
                        </div>
                    </div>
                    <div class="description-section">
                        <span class="description-section-title">Простейшая реализация алгоритма</span>
                        <hr/>
                        <ol>
                            <li>На вход подаётся граф и стартовая вершина.</li>
                            <li>Создаём массив расстояний distance, в котором для каждой вершины будем хранить текущую
                                длину кратчайшего пути из стартовой вершины. Для стартовой вершины distance = 0, для остальных
                                Infinity. Также создаём массив visited для хранения помеченных вершин.
                            </li>
                            <li>Из текущей вершины производим релаксацию.</li>
                            <li>Выбираем следующую вершину с наименьшим расстоянием и возвращаемся к пункту 3</li>
                        </ol>
                        <div class="description-paragraph">После n итераций, где n – количество вершин, алгоритм
                            завершит свою
                            работу.
                        </div>
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image" src="images/dijkstraGif.gif"/>
                </div>
            </div>
        </div>
    </section>

    <!-- Алгорити Беллмана-Форда  -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Алгоритм Беллмана-Форда</span>
            <hr/>
            <div class="description-paragraph">
                <b>Алгоритм Беллмана-Форда</b> – это алгоритм, который позволяет найти кратчайший путь
                из одной вершины графа до всех остальных. Он отличатся от алгоритма Дейкстры тем, что может также
                работать с отрицательными весами. Также этот алгоритм позволяет определить наличие циклов отрицательного
                веса.
                <br>
                <b>Временная сложность алгоритма: </b>O(n<sup>3</sup>), где n – число вершин
            </div>
        </div>
        <div class="description-section">
            <span class="description-section-title">Реализация алгоритма</span>
            <hr/>
            <div class="description-paragraph-row">
                <div>
                    <div class="description-paragraph">Идея алгоритма не отличается от алгоритма Дейкстры, но для
                        реализации удобнее представлять граф в виде списка всех рёбер.
                    </div>
                    <ol>
                        <li>На вход подаётся граф и стартовая вершина.</li>
                        <li>Создаём массив расстояний distance, в котором для каждой вершины будем хранить текущую длину
                            кратчайшего пути из стартовой вершины. Для стартовой вершины distance = 0, для остальных
                            Infinity.
                        </li>
                        <li>Проходимся по всему списку рёбер и если distance[vertex] < Infinity производим релаксацию.
                        </li>
                        <li>Повторяем шаг 2 n-1 раз, где n – количество вершин. После i-й итерации этого шага
                            вычисляются кратчайшие пути длиной не более i ребер. В любом простом пути может быть максимум n-1 ребер,
                            поэтому данный щаг выполняется именно n-1 раз.
                        </li>
                    </ol>
                    <div class="description-paragraph">Для определения цикла отрицательного веса после n-1 шага можно
                        выполним ещё один, и если на нём произойдёт хотя бы одна релаксация, то граф содержит цикл отрицательного
                        веса, в противном случае, такого цикла нет.
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image" src="images/bellmanFordGif.gif"/>
                </div>
            </div>
        </div>
    </section>

    <!-- Алгоритм Флойда-Уоршелла  -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Алгоритм Флойда-Уоршелла</span>
            <hr/>
            <div class="description-paragraph">
                <b>Алгорити Флойда-Уоршелла</b> – это алгоритм, который позволяет найти кратчайшее расстояние между
                всеми вершинами взвешенного графа. Данный алгоритм может быть применён, например, для компьютерной сети, если
                требуется узнать время прохождения пакета от каждого компьютера ко всем остальным.
                <br>
                <b>Временная сложность алгоритма:</b> O(n<sup>3</sup>), где n – число вершин.
            </div>
        </div>
        <div class="description-section">
            <div class="description-paragraph-row">
                <div>
                    <div class="description-section">
                        <span class="description-section-title">Основная идея</span>
                        <hr/>
                        <div class="description-paragraph">Идея заключается в разбиении процесса поиска путей на фазы.
                            Перед k-ой фазой величина distance[i][j] равна длине
                            кратчайшего пути из вершины i в вершину j, если этому пути разрешается заходить только в
                            вершины с номерами меньшими k. Для первой фазы в матрицу расстояний записывается матрица смежности графа,
                            при этом если между вершинами нет ребра, то в ячейку матрицы записывается Infinity. Когда мы находимся на
                            k-ой фазе, и хотим пересчитать матрицу расстояний у нас возникает два случая:
                        </div>
                        <ol>
                            <li>Кратчайший путь из вершины i в вершину j, которому разрешено дополнительно проходить
                                через вершины {1, …, k}, совпадает с кратчайшим путём, которому разрешено проходить через вершины множества
                                {1, …, k - 1}, в этом случае distance[i][j] не изменится;
                            </li>
                            <li>«Новый» путь стал лучше предыдущего, т.е. мы нашли такие вершины, что distance[i][k] +
                                distance[k][j] < distance[i][j];
                            </li>
                        </ol>
                        <div class="description-paragraph">Если мы объединим эти условия, то получится, что кратчайший
                            путь можно найти по формуле
                            distance[i][j] = min (distance[i][k] + distance[k][j], distance[i][j]).
                            Для восстановления пути нужно использовать матрицу предков, которая для каждой пары
                            вершин будет
                            содержать номер фазы, на которой было получено кратчайшее расстояние между ними.
                        </div>
                    </div>
                    <div class="description-section">
                        <span class="description-section-title">Реализация алгоритма</span>
                        <hr/>
                        <div class="description-paragraph-row">
                            <div>
                                <ol>
                                    <li>На вход подаётся граф в виде матрицы смежности размером n x n, в котором каждый
                                        элемент задаёт длину ребра между соответствующими вершинами, если ребра между вершинами
                                        нет, то в ячейку записывается Infinity.
                                    </li>
                                    <li>Создаём цикл фаз и проходимся по нему n раз.</li>
                                    <li>Внутри цикла проходимся по матрице и вычисляем distance[i][j] = min
                                        (distance[i][k] + distance[k][j], distance[i][j]).
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image" src="images/floyd.jpg"/>
                </div>
            </div>
        </div>

    </section>

    <!-- Алгоритм Прима  -->
    <section class="algo-section">
        <div class="description-section">
            <span class="description-section-title description-section-title-main">Алгоритм Прима</span>
            <hr/>
            <div class="description-paragraph">
                <b>Алгоритм Прима</b> – это алгоритм, который позволяет в неориентированном
                графе найти такое поддерево этого графа, которое бы соединяло все его вершины, и при этом обладало
                наименьшим возможным весом. <b>Поддерево</b> – это подмножество рёбер графа, соединяющих все вершины, и
                из любой вершины до любой другой можно добраться одним простым путём. Такое поддерево называется
                минимальным остовом. Данные алгоритм применяется, например, для создания деревьев для распределения
                данных в компьютерных сетях, для сегментации изображений, в кластерном анализе.
                <br>
                Время работы алгоритма зависит от реализации, самая тривиальная реализация занимает O(nm), в случае
                плотных графов – O(n<sup>2</sup>), в оптимальном случае алгоритм может работать за O(m logn), где n –
                число вершин, а m – число рёбер, для этого нужно использовать очередь с приоритетом.
            </div>
        </div>
        <div class="description-section">
            <div class="description-paragraph-row">
                <div>
                    <div class="description-section">
                        <span class="description-section-title">Основная идея</span>
                        <hr/>
                        <div class="description-paragraph">Суть алгоритма состоит в постепенном строительстве
                            минимального остова, добавление в
                            него рёбер происходит по одному. Изначально остов состоит из одной вершины, затем выбирается ребро
                            минимального веса, исходящего из этой вершины и добавляется в минимальный остов, дальше продолжаем
                            искать минимальное по весу ребро, имеющее один конец в одной из выбранных вершин, а другой в
                            ещё невыбранных. Процесс повторяется пока остов не будет содержать все вершины.
                        </div>
                    </div>
                    <div class="description-section">
                        <span class="description-section-title">Реализация алгоритма</span>
                        <hr/>
                        <div class="description-paragraph-row">
                            <div>
                                <ol>
                                    <li>На вход подаётся граф в виде матрицы смежности размером n x n, в котором каждый
                                        элемент задаёт длину ребра между соответствующими вершинами, если ребра между вершинами
                                        нет, то в ячейку записывается Infinity.
                                    </li>
                                    <li>Создаем массив visited, в котором будут храниться вершины, включенные в остов,
                                        массив minEdge, в котором будет храниться вес наименьшего допустимого ребра из вершины
                                        i, и массив selectedEdge, который содержит конец этого наименьшего ребра.
                                    </li>
                                    <li>Выбираем любую вершину vertex, из которой будем строить остов, и полагаем
                                        minEdge[vertex] = 0
                                    </li>
                                    <li>Создаём цикл длинной n-1</li>
                                    <li>Внутри цикла выбираем вершину с наименьшей меткой minEdge, кладём ей в visited,
                                        и просматривает все рёбра из этой вершины, пересчитывая их метки
                                    </li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="description-image-container">
                    <img class="description-image" src="images/prima.gif"/>
                </div>
            </div>
        </div>

    </section>
</div>
<script src="js/get-document-height.js"></script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Бинарное дерево поиска</title>
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>

<div class="description">
  <div class="description-section">
    <span class="description-section-title">Определение</span>
    <hr />
    <div class="description-paragraph">
      <b>Бинарное дерево поиска</b> — это двоичное дерево, для которого выполняются следующие
      дополнительные условия (свойства дерева поиска):
      <ul>
        <li>Каждый узел имеет не более двух потомков.</li>
        <li>
          У всех узлов левого поддерева произвольного узла X значения ключей данных меньше,
          чем значение ключа данных самого узла X.
        </li>
        <li>
          У всех узлов правого поддерева произвольного узла X значения ключей данных больше
          либо равны, чем значение ключа данных самого узла X.
        </li>
      </ul>
    </div>
    <div class="description-paragraph">
      Основным преимуществом бинарного дерева поиска перед другими структурами данных является
      возможная высокая эффективность реализации основанных на нём алгоритмов поиска и сортировки.
    </div>
  </div>
  <div class="description-section">
    <span class="description-section-title">Основные понятия</span>
    <hr />
    <div class="description-paragraph">
      <div class="description-paragraph-row">
        <div class="w-75">
          <ul>
            <li>
              <b>Корневой узел</b> — это узел, находящийся на самом верхнем уровне и не являющийся
              чьим-либо потомком (узел 8).
            </li>
            <li>
              <b>Лист</b> — это узел, не имеющий дочерних элементов (узлы 1, 4, 10, 13).
            </li>
            <li>
              <b>Внутренний узел</b> — это любой узел дерева, имеющий потомков, то есть, не являющийся
              листовым узлом (узлы 8, 3, 5, 9, 12).
            </li>
            <li>
              <b>Высота узла</b> — это длина наибольшего пути от него до дочернего узла, являющегося
              листом.
            </li>
            <li>
              <b>Высота дерева</b> — это длина наибольшего пути от корня к листу (высота дерева на примере
              равна 3).
            </li>
          </ul>
        </div>
        <div class="w-25">
          <div class="description-image-container">
            <img class="description-image" src="images/example.png" alt="binary-tree example" />
            <span class="description-image-title">Простой пример бинарного дерева</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="description-section">
    <span class="description-section-title">Основные операции</span>
    <hr />
    <div class="description-paragraph">
      Основными операциями в бинарном дереве поиска являются:
      <ul>
        <li><i>INSERT(K, V)</i> — добавление в дерево пары (key, value) = (K, V).</li>
        <li><i>FIND(K)</i> — поиск узла, в котором хранится пара (key, value) с key = K.</li>
        <li>
          <i>REMOVE(K)</i> — удаление узла, в котором хранится пара (key, value) с key = K.
        </li>
      </ul>
    </div>
    <div class="description-paragraph">
      <div class="description-paragraph-title">Вставка элемента</div>
      <div class="description-paragraph-row">
        <div class="w-50">
          <b>Задача:</b> вставить пару (K, V) в дерево Т (при совпадении K, заменить V).<br />
          <b>Алгоритм:</b>
          <ul>
            <li>
              Если дерево пусто, заменить его на дерево с одним корневым узлом (K, V) и
              остановиться.
            </li>
            <li>
              Иначе сравнить K со значением ключа корневого узла X.
              <ul>
                <li>
                  Если K>X, рекурсивно добавить (K, V) в правое поддерево Т.
                </li>
                <li>
                  Если K&lt;X, рекурсивно добавить (K, V) в левое поддерево Т.
                </li>
                <li>
                  Если K=X, заменить V текущего узла новым значением.
                </li>
              </ul>
            </li>
          </ul>
        </div>
        <div class="w-50">
          <div class="description-image-container">
            <img class="description-image" src="images/insert.gif" alt="binary-tree insert" />
            <span class="description-image-title">Вставка узла 42</span>
          </div>
        </div>
      </div>
    </div>
    <div class="description-paragraph">
      <div class="description-paragraph-title">Поиск элемента</div>
      <div class="description-paragraph-row">
        <div class="w-50">
          <b>Задача:</b> проверить, есть ли узел с ключом K в дереве Т, и если да, то вернуть ссылку
          на этот узел.<br />
          <b>Алгоритм:</b>
          <ul>
            <li>Если дерево пусто, сообщить, что узел не найден, и остановиться.</li>
            <li>
              Иначе сравнить K со значением ключа корневого узла X.
              <ul>
                <li>
                  Если K=X, выдать ссылку на этот узел и остановиться.
                </li>
                <li>
                  Если K>X, рекурсивно искать ключ K в правом поддереве Т.
                </li>
                <li>
                  Если K&lt;X, рекурсивно искать ключ K в левом поддереве Т.
                </li>
              </ul>
            </li>
          </ul>
        </div>
        <div class="w-50">
          <div class="description-image-container">
            <img class="description-image" src="images/find.gif" alt="binary-tree find" />
            <span class="description-image-title">Поиск узла 14</span>
          </div>
        </div>
      </div>
    </div>
    <div class="description-paragraph">
      <div class="description-paragraph-title">Удаление элемента</div>
      <div class="description-paragraph-row">
        <div class="w-50">
          <b>Задача:</b> удалить из дерева Т узел с ключом K (если такой есть).<br />
          <b>Алгоритм:</b>
          <ul>
            <li>Если дерево T пусто, остановиться;</li>
            <li>
              Иначе сравнить K со значением ключа корневого узла Х.
              <ul>
                <li>
                  Если K>X, рекурсивно удалить K из правого поддерева Т;
                </li>
                <li>
                  Если K&lt;X, рекурсивно удалить K из левого поддерева Т;
                </li>
                <li>
                  Если K=X, то необходимо рассмотреть три случая:
                  <ul>
                    <li>
                      Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на
                      него у родительского узла;
                    </li>
                    <li>
                      Если одного из детей нет, то значения полей ребёнка m ставим вместо
                      соответствующих значений корневого узла;
                    </li>
                    <li>
                      Если оба ребёнка присутствуют, то:
                      <ul>
                        <li>
                          Если левый узел m правого поддерева отсутствует, то копируем
                          из правого узла в удаляемый поля K, V и ссылку на правый
                          узел правого потомка.
                        </li>
                        <li>
                          Иначе
                          <ul>
                            <li>
                              Возьмём самый левый узел m правого поддерева;
                            </li>
                            <li>
                              Скопируем данные (кроме ссылок на дочерние элементы)
                              из m в X;
                            </li>
                            <li>
                              Рекурсивно удалим узел m.
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </div>
        <div class="w-50">
          <div class="description-image-container">
            <img class="description-image" src="images/remove.gif" alt="binary-tree remove" />
            <span class="description-image-title">Удаление узла 18</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="description-section">
    <span class="description-section-title">Обход дерева</span>
    <hr />
    <div class="description-paragraph-row">
      <div class="w-75">
        <div class="description-paragraph">
          <b>Обход дерева</b> — это процесс посещения каждого узла структуры дерева данных ровно
          один раз.
          Обход дерева итеративно проходит по всем узлам согласно некоторому алгоритму.
          Поскольку из данного узла имеется более одного следующего узла, то некоторые узлы должны
          быть отложены,
          то есть запомнены некоторым способом для дальнейшего посещения.
          Деревья можно обходить «в глубину» или «в ширину». Существует три основных способа
          обхода «в глубину»:
          <ul>
            <li>прямой (pre-order)</li>
            <li>центрированный (in-order)</li>
            <li>обратный (post-order)</li>
          </ul>
        </div>
        <div class="description-paragraph">
          <div class="description-paragraph-title">Прямой обход</div>
          <ol>
            <li>Проверяем, не является ли текущий узел пустым или null.</li>
            <li>Показываем поле данных корня (или текущего узла).</li>
            <li>Обходим левое поддерево рекурсивно, вызвав функцию прямого обхода.</li>
            <li>Обходим правое поддерево рекурсивно, вызвав функцию прямого обхода.</li>
          </ol>
        </div>
        <div class="description-paragraph">
          <div class="description-paragraph-title">Центрированный обход</div>
          <ol>
            <li>Проверяем, не является ли текущий узел пустым или null.</li>
            <li>Обходим левое поддерево рекурсивно, вызвав функцию центрированного обхода.</li>
            <li>Показываем поле данных корня (или текущего узла).</li>
            <li>Обходим правое поддерево рекурсивно, вызвав функцию центрированного обхода.</li>
          </ol>
          В двоичном дереве поиска центрированный обход извлекает данные в отсортированном
          порядке.
        </div>
        <div class="description-paragraph">
          <div class="description-paragraph-title">Обратный обход</div>
          <ol>
            <li>Проверяем, не является ли текущий узел пустым или null.</li>
            <li>Обходим левое поддерево рекурсивно, вызвав функцию обратного обхода.</li>
            <li>Обходим правое поддерево рекурсивно, вызвав функцию обратного обхода.</li>
            <li>Показываем поле данных корня (или текущего узла).</li>
          </ol>
        </div>
        <div class="description-paragraph">
          <div class="description-paragraph-title">Поиск в ширину</div>
          Деревья можно обходить также в порядке уровней, где мы посещаем каждый узел на уровне
          прежде чем перейти на следующий уровень.
        </div>
      </div>
      <div class="w-25">
        <div class="description-paragraph">
          <div class="description-image-container">
            <img class="description-image" src="images/pre-order.png" alt="binary-tree pre-order" />
            <span class="description-image-title">Прямой: F, B, A, D, C, E, G, I, H</span>
          </div>
          <div class="description-image-container">
            <img class="description-image" src="images/in-order.png" alt="binary-tree in-order" />
            <span class="description-image-title">Центрированный: A, B, C, D, E, F, G, H, I</span>
          </div>
          <div class="description-image-container">
            <img class="description-image" src="images/post-order.png" alt="binary-tree post-order" />
            <span class="description-image-title">Обратный: A, C, E, D, B, H, I, G, F</span>
          </div>
          <div class="description-image-container">
            <img class="description-image" src="images/bfs.png" alt="binary-tree bfs" />
            <span class="description-image-title">Поиск в ширину: F, B, G, A, D, I, C, E, H</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="description-section">
    <span class="description-section-title">Сбалансированные и несбалансированные деревья</span>
    <hr />
    <div class="description-paragraph-row">
      <div class="w-75">
        <div class="description-paragraph">
          <b>Сбалансированное дерево</b> — это такое дерево, для каждого узла которого количество
          узлов в его левом и правом поддеревьях
          различается не более, чем на 1 (рис. 1).
        </div>
        <div class="description-paragraph">
          Само по себе бинарное дерево поиска не является сбалансированным деревом, и в худшем
          случае вырождается в список (рис. 2).
          При этом теряется производительность, поэтому для наилучшего быстродействия
          желательно,чтобы глубина и левого, и правого поддеревьев
          в каждом узле была примерно одинакова. Из-за этого ограничения на практике чаще всего
          используются сбалансированные деревья (например, AVL-дерево или красно-чёрное дерево).
        </div>
        <div class="description-paragraph">
          Однако обычные бинарные деревья также могут оказаться полезны. Как показывает практика,
          они ничем не уступают сбалансированным
          деревьям при работе со случайным неупорядоченным набором данных. В совокупности с их
          довольно простой реализацией, это позволяет
          сделать выбор в пользу обычных бинарных деревьев (именно на наборе случайных данных).
        </div>
      </div>
      <div class="w-25">
        <div class="description-image-container">
          <img class="description-image" src="images/balanced.png" alt="binary-tree balanced" />
          <span class="description-image-title">Сбалансированное дерево</span>
        </div>
        <div class="description-image-container">
          <img class="description-image" src="images/unbalanced.png" alt="binary-tree unbalanced" />
          <span class="description-image-title">Несбалансированное дерево</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="js/get-document-height.js"></script>
</body>
</html>


